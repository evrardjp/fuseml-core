# FuseML Core

This repository contains the FuseML APIs definitions and core service.

Code structure:
* `api/swagger.yaml` - openapi specification consumed by go-swagger out of which REST API server and client code are generated
* `pkg` - fuseml-core golang code is located here and organized as follows:
  * `api` - go-swagger generated code for the REST server and server operations
  * `models` - go-swagger generated code for the REST model
  * `client` - go-swagger generated code for the REST client. This golang package should be imported by the code (not included in this repo) that implements the CLI
  * `service/runnable` - this package implements the core logic for a simple, in-memory runnable store and ties it into the REST API server handlers generated by swagger
  * `cmd/fuseml_core.go` - this is the main entry point for the fuseml core service. It also started out as one of the server files generated by go-swagger.


How to build and run:
* install build prerequisites:
  * `go get github.com/go-swagger/go-swagger/cmd/swagger`
* run `make` to generate server and client code and build the `bin/fuseml_core` binary
* run the binary (NOTE: use the `--help` flag to get the command line options that you can supply. It's recommended to configure at least the `--port`, otherwise you get a random HTTP port value)

Some reflection on the draft implementation of this service and immediate improvements it could use:
* the current code doesn't follow the clean architecture and domain driven design recommendations:
  * the business rules (aka the business domain, or entities) are not clearly defined using an independent code package. The `pkg/models` package generated by go-swagger is used instead, because it's convenient and because the data structures generated there by go-swagger are highly similar to the basic entities used to describe business logic. This approach is not recommended for long-term use, because it is based on the false assumption that the REST API data structures (i.e. the REST requests and responses) are equivalent to the data structures needed to express the business logic. It also allows the business domain code to be polluted with aspects that it shouldn't be concerned with, such as HTTP serialization/deserialization.
  * it's recommended that the runnable store interface be defined and kept separately from its implementation (i.e. in different packages), to decouple the back-end and the front-end
* configuration options should be modeled not just as command line flags, but using 3 different sources that can override one another: environment variables (highest priority), command line flags and configuration file (lowest priority). This facilitates running the service as a container. There might be an open source solution that can help with this.
